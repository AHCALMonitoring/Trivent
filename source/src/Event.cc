  /// \file Event.cc
/*
 *
 * Event.cc source template automatically generated by a class generator
 * Creation date : ven. mars 18 2016
 *
 * This file is part of Trivent libraries.
 * 
 * Trivent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * Trivent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Trivent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

// -- trivent headers
#include "Event.h"
#include "Unit.h"

namespace trivent
{

Event::Event() :
		m_pUserEvent(NULL),
		m_timeStamp(0)
{
	/* nop */
}

//-------------------------------------------------------------------------------------------------

Event::~Event()
{
	this->clear(true);
}

//-------------------------------------------------------------------------------------------------

void Event::setUserEvent(void *pUserEvent)
{
	m_pUserEvent = pUserEvent;
}

//-------------------------------------------------------------------------------------------------

void *Event::getUserEvent() const
{
	return m_pUserEvent;
}

//-------------------------------------------------------------------------------------------------

void Event::setTimeStamp(uint64_t timeStamp)
{
	m_timeStamp = timeStamp;
}

//-------------------------------------------------------------------------------------------------

uint64_t Event::getTimeStamp() const
{
	return m_timeStamp;
}

//-------------------------------------------------------------------------------------------------

void Event::clear(bool deepClean)
{
	if(deepClean)
	{
		for(UnitCollectionMap::iterator iter = m_unitCollectionMap.begin(), endIter = m_unitCollectionMap.end() ;
				endIter != iter ; ++iter)
		{
			for(UnitSet::iterator iter2 = iter->second.begin(), endIter2 = iter->second.end() ;
					endIter2 != iter2 ; ++iter2)
			{
				delete *iter2;
			}
		}
	}

	m_unitCollectionMap.clear();
}

//-------------------------------------------------------------------------------------------------

void Event::addUnit(const std::string &collectionName, Unit *pUnit)
{
	m_unitCollectionMap[collectionName].insert(pUnit);
	pUnit->setCollectionName(collectionName);
}

//-------------------------------------------------------------------------------------------------

void Event::addUnits(const std::string &collectionName, const UnitSet &inputUnitSet)
{
	UnitSet &unitSet = m_unitCollectionMap[collectionName];

	for(UnitSet::iterator iter = inputUnitSet.begin(), endIter = inputUnitSet.end() ;
			endIter != iter ; ++iter)
	{
		unitSet.insert(*iter);
		(*iter)->setCollectionName(collectionName);
	}
}

//-------------------------------------------------------------------------------------------------

void Event::removeUnit(const std::string &collectionName, Unit *pUnit, bool callDelete)
{
	if(NULL == pUnit)
		return;

	UnitCollectionMap::iterator iter = m_unitCollectionMap.find(collectionName);

	if(iter == m_unitCollectionMap.end())
		return;

	size_t erased = iter->second.erase(pUnit);

	if( ! erased )
		return;

	pUnit->setCollectionName("");

	if(callDelete)
		delete pUnit;
}

//-------------------------------------------------------------------------------------------------

void Event::removeUnits(const std::string &collectionName, const UnitSet &inputUnitSet, bool callDelete)
{
	if(inputUnitSet.empty())
		return;

	UnitCollectionMap::iterator findIter = m_unitCollectionMap.find(collectionName);

	if(findIter == m_unitCollectionMap.end())
		return;

	for(UnitSet::iterator iter = inputUnitSet.begin(), endIter = inputUnitSet.end() ;
			endIter != iter ; ++iter)
	{
		size_t erased = findIter->second.erase(*iter);

		if( ! erased )
			continue;

		(*iter)->setCollectionName("");

		if(callDelete)
			delete *iter;
	}
}

//-------------------------------------------------------------------------------------------------

void Event::getUnits(const std::string &collectionName, UnitSet &unitSet) const
{
	UnitCollectionMap::const_iterator findIter = m_unitCollectionMap.find(collectionName);

	if(findIter == m_unitCollectionMap.end())
		return;

	unitSet.insert(findIter->second.begin(), findIter->second.end());
}

//-------------------------------------------------------------------------------------------------

std::vector<std::string> Event::getCollectionNames() const
{
	std::vector<std::string> collectionNames;

	for(UnitCollectionMap::const_iterator iter = m_unitCollectionMap.begin(), endIter = m_unitCollectionMap.end() ;
			endIter != iter ; ++iter)
	{
		collectionNames.push_back(iter->first);
	}

	return collectionNames;
}

} 

