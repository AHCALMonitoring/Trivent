  /// \file LCTrivent.cc
/*
 *
 * LCTrivent.cc source template automatically generated by a class generator
 * Creation date : dim. mars 20 2016
 *
 * This file is part of Trivent libraries.
 * 
 * Trivent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * Trivent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with Trivent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "LCTrivent.h"

#include "IMPL/LCEventImpl.h"
#include "IMPL/LCCollectionVec.h"
#include "IMPL/LCFlagImpl.h"

namespace trivent
{

void LCTriventListener::startProcessingInputEvent(const Event *const pInputEvent)
{
	this->storeCollectionTypeMap(pInputEvent);
}

//-------------------------------------------------------------------------------------------------

void LCTriventListener::processReconstructedEvent(const Event *const pReconstructedEvent)
{
	EVENT::LCEvent *pLCEvent = this->createLCEvent(pReconstructedEvent);

	if( ! pLCEvent )
		return;

	this->processReconstructedEvent( pLCEvent );
	delete pLCEvent;
}

//-------------------------------------------------------------------------------------------------

void LCTriventListener::storeCollectionTypeMap(const Event *const pInputEvent)
{
	m_collectionTypeMap.clear();

	std::vector<std::string> collectionNames = pInputEvent->getCollectionNames();

	for(std::vector<std::string>::iterator iter = collectionNames.begin(), endIter = collectionNames.end() ;
			endIter != iter ; ++iter)
	{
		UnitSet unitSet;
		pInputEvent->getUnits(*iter, unitSet);

		// units within the same collection share the same type
		std::string type = (*unitSet.begin())->getType();

		m_collectionTypeMap[ *iter ] = type;
	}
}

//-------------------------------------------------------------------------------------------------

EVENT::LCEvent *LCTriventListener::createLCEvent(const Event *const pReconstructedEvent)
{
	if( m_collectionTypeMap.empty() )
		return 0;

	IMPL::LCEventImpl *pLCEvent = new IMPL::LCEventImpl();

	std::vector<std::string> collectionNames = pReconstructedEvent->getCollectionNames();

	for(std::vector<std::string>::iterator colIter = collectionNames.begin(), colEndIter = collectionNames.end() ;
			colEndIter != colIter ; ++colIter)
	{
		std::map<std::string, std::string>::iterator findIter = m_collectionTypeMap.find( *colIter );

		if( findIter == m_collectionTypeMap.end() )
			continue;

		UnitSet unitSet;
		pReconstructedEvent->getUnits( *colIter , unitSet );

		IMPL::LCFlagImpl lcFlag;
		lcFlag.setBit(EVENT::LCCollection::BITSubset);

		IMPL::LCCollectionVec *pLCCollection = new IMPL::LCCollectionVec(findIter->second);
		pLCCollection->setFlag( lcFlag.getFlag() );

		for(UnitSet::iterator iter = unitSet.begin(), endIter = unitSet.end() ;
				endIter != iter ; ++iter)
		{
			EVENT::LCObject *pLCObject = static_cast<EVENT::LCObject *>( (*iter)->getUserInput() );

			if( NULL == pLCObject )
				continue;

			pLCCollection->addElement( pLCObject );
		}

		pLCEvent->addCollection( pLCCollection , findIter->first );
	}

	return pLCEvent;
}

} 

